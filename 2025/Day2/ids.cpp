/**
 * 
 * @author Holden Kuempel
 * 
 * This program was developed to solve the 2025 Advent of Code Day 2, parts 1 and 2.
 * 
 * The challenge involves a series of ID ranges with various invalid IDs sprinkled in. An ID is considered 
 * invalid if it is composed of entirely repeated parts.In part 1 of this challenge an ID is considered invalid 
 * if it is made up of exactly two repeated parts, like 11 or 1212. However in part 2 of this challenge any 
 * number of repeated components are consider invalid which would still include numbers like 11 and 1212, 
 * but also 111 and 12121212. The actual solution to solving these parts however, is the sumation of invalid 
 * IDs, not the number of them.
 *
 * This program may take in an argument of 1 or 2. If it is provided it will only run that part of the challenge.
 * Otherwise, it will run both parts.
 *
 * To complete this challenge yourself go to: https://adventofcode.com/2025/day/2
 */
 
#include "ids.hpp"

ull sum = 0; // This is the sum of the ids for each part.
// These vectors will be used only for part 2 and refreshed after each range/
std::vector<ull> repeatedIDs; // This vector contains IDs which may be repeated during the insertion process.
std::vector<ull> unrepeatedIDs; // This vector contains a single copy of each ID within the other vector.

// partOne is solved by taking the number of digits within the minimum and halfing and creating every possible 
// number that is generated by taking a number segement and concatenating it with itself, until the number of 
// digits exceeds half the numnber of digits in the maximum value.
ull partOne()
{
	sum = 0;
	std::string line;
	std::ifstream input ("input.txt");
	std::ofstream output ("logPart1.txt");
	if (input.is_open() && output.is_open())
	{
		output << "range\n" << "\tInvalid Ids\n\n";
		
		while (std::getline(input, line, ','))
		{
			int dashIndex = line.find('-');
			std::string minstr = line.substr(0, dashIndex);
			std::string maxstr = line.substr(dashIndex + 1, line.length() - dashIndex);
			ull min = stoull(minstr); ull max = stoull(maxstr);
			output << line << std::endl;
			ull curID = 0; // The ID that will be verified as valid ot invalid.
			// i is the number of digits for which we are repeating.
			for (int i = minstr.length() / 2; i <= (int) maxstr.length() / 2; i++)
			{
				// j is the iterator for each possible invalid id.	
				for (ull j = (ull) (pow(10, i - 1)); j <= (ull) (pow(10, i) - 1); j++)
				{
					std::string idsubstr = std::to_string(j); // Converts j into a string.
					std::string idstr = idsubstr + idsubstr; // Conconates the substrings together.
					curID = stoull(idstr); // Creates an invalid id, that may be within the range in question.
					if (min <= curID && curID <= max)
					{
						sum += curID;
						output << "\t" << curID << std::endl;
					}
				}
			}
			output << std::endl;
		}
	}
	input.close();
	output.close();
	return sum;
}

// partTwo is solved by generating numbers of any digit length from 1 to max.length() / 2 and concateing it with 
// itself, until it falls beyond the range of possible values. Since within this part repeats can occur to vectors
// are used to verify that no ID is repeated.
ull partTwo()
{
	sum = 0;
	std::string line;
	std::ifstream input ("input.txt");
	std::ofstream output ("logPart2.txt");
	if (input.is_open() && output.is_open())
	{
		output << "range\n" << "\tInvalid Ids\n\n";
		while (std::getline(input, line, ','))
		{
			repeatedIDs.clear();
			unrepeatedIDs.clear();
			int dashIndex = line.find('-');
			std::string minstr = line.substr(0, dashIndex);
			std::string maxstr = line.substr(dashIndex + 1, line.length() - dashIndex);
			ull min = stoull(minstr); ull max = stoull(maxstr);
			output << line << std::endl;
			ull curID = 0;
			for (int i = 1; i <= (int) maxstr.length() / 2; i++)
			{
				for (int j = 2; i * j <= (int) maxstr.length(); j++)
				{
					for (ull k = (ull) (pow(10, i - 1)); k <= (ull) (pow(10, i) - 1); k++)
					{
						std::string idsubstr = std::to_string(k);
						std::string idstr = idsubstr;
						for (int l = 1; l < j; l++) {idstr += idsubstr;}
						curID = stoull(idstr);
						if (min <= curID && curID <= max)
						{
							repeatedIDs.push_back(curID);
						}
					}
				}
			}
			std::sort(repeatedIDs.begin(), repeatedIDs.end());
			validateIDs();
			std::vector<ull>::iterator it;
			for (it = unrepeatedIDs.begin(); it != unrepeatedIDs.end(); ++it)
			{
				output << "\t" << *it << std::endl;
			}
			output << std::endl;
		}
	}
	input.close();
	output.close();
	return sum;
}

void validateIDs()
{
	std::vector<ull>::iterator it;
	for (it = repeatedIDs.begin(); it != repeatedIDs.end(); ++it)
	{
		if (unrepeatedIDs.empty())
		{
			unrepeatedIDs.push_back(*it);
			sum += *it;
		}
		else if (unrepeatedIDs.back() != *it)
		{
			unrepeatedIDs.push_back(*it);
			sum += *it;
		}
	}
}

int main(int argc, char* argv[])
{
	if (argc >= 2 && *argv[1] == '1')
	{
		std::cout << "Running just Part One" << std::endl;
		std::cout << "Sum of invalid IDs: " << partOne() << std::endl;
		return 0;
	}
	else if (argc >= 2 && *argv[1] == '2')
	{
		std::cout << "Running Just Part Two" << std::endl;
		std::cout << "Sum of invalid IDs: " << partTwo() << std::endl;
		return 0;
	}
	else
	{
		std::cout << "Sum of invalid IDs for part one: " << partOne() << std::endl;
		std::cout << "Sum of invalid IDs for part two: " << partTwo() << std::endl;
		return 0;
	}
}
